{"mappings":"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","sources":["src/libsodium.js","src/wrapper.ts"],"sourcesContent":["//@ts-check\nconst libsodiumModule = function (Module = {}) {\n  var readyPromiseResolve, readyPromiseReject;\n\n  Module[\"ready\"] = new Promise(function (resolve, reject) {\n    readyPromiseResolve = resolve;\n    readyPromiseReject = reject;\n  });\n\n  var err = Module[\"printErr\"] || console.warn.bind(console);\n  if (typeof WebAssembly !== \"object\") {\n    abort(\"no native wasm support detected\");\n  }\n\n  function setValue(ptr, value, type, noSafe) {\n    type = type || \"i8\";\n    if (type.charAt(type.length - 1) === \"*\") type = \"i32\";\n    switch (type) {\n      case \"i1\":\n        HEAP8[ptr >> 0] = value;\n        break;\n\n      case \"i8\":\n        HEAP8[ptr >> 0] = value;\n        break;\n\n      case \"i16\":\n        HEAP16[ptr >> 1] = value;\n        break;\n\n      case \"i32\":\n        HEAP32[ptr >> 2] = value;\n        break;\n\n      case \"i64\":\n        (tempI64 = [\n          value >>> 0,\n          ((tempDouble = value),\n          +Math.abs(tempDouble) >= 1\n            ? tempDouble > 0\n              ? (Math.min(+Math.floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0\n              : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0\n            : 0),\n        ]),\n          (HEAP32[ptr >> 2] = tempI64[0]),\n          (HEAP32[(ptr + 4) >> 2] = tempI64[1]);\n        break;\n\n      case \"float\":\n        HEAPF32[ptr >> 2] = value;\n        break;\n\n      case \"double\":\n        HEAPF64[ptr >> 3] = value;\n        break;\n\n      default:\n        abort(\"invalid type for setValue: \" + type);\n    }\n  }\n\n  function getValue(ptr, type, noSafe) {\n    type = type || \"i8\";\n    if (type.charAt(type.length - 1) === \"*\") type = \"i32\";\n    switch (type) {\n      case \"i1\":\n        return HEAP8[ptr >> 0];\n\n      case \"i8\":\n        return HEAP8[ptr >> 0];\n\n      case \"i16\":\n        return HEAP16[ptr >> 1];\n\n      case \"i32\":\n        return HEAP32[ptr >> 2];\n\n      case \"i64\":\n        return HEAP32[ptr >> 2];\n\n      case \"float\":\n        return HEAPF32[ptr >> 2];\n\n      case \"double\":\n        return HEAPF64[ptr >> 3];\n\n      default:\n        abort(\"invalid type for getValue: \" + type);\n    }\n    return null;\n  }\n\n  var wasmMemory;\n\n  var ABORT = false;\n\n  var EXITSTATUS;\n\n  function assert(condition, text) {\n    if (!condition) {\n      abort(\"Assertion failed: \" + text);\n    }\n  }\n\n  var UTF8Decoder = typeof TextDecoder !== \"undefined\" ? new TextDecoder(\"utf8\") : undefined;\n\n  function UTF8ArrayToString(heap, idx, maxBytesToRead) {\n    var endIdx = idx + maxBytesToRead;\n    var endPtr = idx;\n    while (heap[endPtr] && !(endPtr >= endIdx)) ++endPtr;\n    if (endPtr - idx > 16 && heap.subarray && UTF8Decoder) {\n      return UTF8Decoder.decode(heap.subarray(idx, endPtr));\n    } else {\n      var str = \"\";\n      while (idx < endPtr) {\n        var u0 = heap[idx++];\n        if (!(u0 & 128)) {\n          str += String.fromCharCode(u0);\n          continue;\n        }\n        var u1 = heap[idx++] & 63;\n        if ((u0 & 224) == 192) {\n          str += String.fromCharCode(((u0 & 31) << 6) | u1);\n          continue;\n        }\n        var u2 = heap[idx++] & 63;\n        if ((u0 & 240) == 224) {\n          u0 = ((u0 & 15) << 12) | (u1 << 6) | u2;\n        } else {\n          u0 = ((u0 & 7) << 18) | (u1 << 12) | (u2 << 6) | (heap[idx++] & 63);\n        }\n        if (u0 < 65536) {\n          str += String.fromCharCode(u0);\n        } else {\n          var ch = u0 - 65536;\n          str += String.fromCharCode(55296 | (ch >> 10), 56320 | (ch & 1023));\n        }\n      }\n    }\n    return str;\n  }\n\n  function UTF8ToString(ptr, maxBytesToRead) {\n    return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : \"\";\n  }\n\n  function alignUp(x, multiple) {\n    if (x % multiple > 0) {\n      x += multiple - (x % multiple);\n    }\n    return x;\n  }\n\n  var buffer, HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;\n\n  function updateGlobalBufferAndViews(buf) {\n    buffer = buf;\n    Module[\"HEAP8\"] = HEAP8 = new Int8Array(buf);\n    Module[\"HEAP16\"] = HEAP16 = new Int16Array(buf);\n    Module[\"HEAP32\"] = HEAP32 = new Int32Array(buf);\n    Module[\"HEAPU8\"] = HEAPU8 = new Uint8Array(buf);\n    Module[\"HEAPU16\"] = HEAPU16 = new Uint16Array(buf);\n    Module[\"HEAPU32\"] = HEAPU32 = new Uint32Array(buf);\n    Module[\"HEAPF32\"] = HEAPF32 = new Float32Array(buf);\n    Module[\"HEAPF64\"] = HEAPF64 = new Float64Array(buf);\n  }\n\n  var INITIAL_MEMORY = Module[\"INITIAL_MEMORY\"] || 16777216;\n\n  var wasmTable;\n\n  var __ATPRERUN__ = [];\n\n  var __ATINIT__ = [];\n\n  var __ATPOSTRUN__ = [];\n\n  var runtimeInitialized = false;\n\n  function preRun() {\n    if (Module[\"preRun\"]) {\n      if (typeof Module[\"preRun\"] == \"function\") Module[\"preRun\"] = [Module[\"preRun\"]];\n      while (Module[\"preRun\"].length) {\n        addOnPreRun(Module[\"preRun\"].shift());\n      }\n    }\n    callRuntimeCallbacks(__ATPRERUN__);\n  }\n\n  function initRuntime() {\n    runtimeInitialized = true;\n    callRuntimeCallbacks(__ATINIT__);\n  }\n\n  function postRun() {\n    if (Module[\"postRun\"]) {\n      if (typeof Module[\"postRun\"] == \"function\") Module[\"postRun\"] = [Module[\"postRun\"]];\n      while (Module[\"postRun\"].length) {\n        addOnPostRun(Module[\"postRun\"].shift());\n      }\n    }\n    callRuntimeCallbacks(__ATPOSTRUN__);\n  }\n\n  function addOnPreRun(cb) {\n    __ATPRERUN__.unshift(cb);\n  }\n\n  function addOnInit(cb) {\n    __ATINIT__.unshift(cb);\n  }\n\n  function addOnPostRun(cb) {\n    __ATPOSTRUN__.unshift(cb);\n  }\n\n  var runDependencies = 0;\n\n  var runDependencyWatcher = null;\n\n  var dependenciesFulfilled = null;\n\n  function addRunDependency(id) {\n    runDependencies++;\n    if (Module[\"monitorRunDependencies\"]) {\n      Module[\"monitorRunDependencies\"](runDependencies);\n    }\n  }\n\n  function removeRunDependency(id) {\n    runDependencies--;\n    if (Module[\"monitorRunDependencies\"]) {\n      Module[\"monitorRunDependencies\"](runDependencies);\n    }\n    if (runDependencies == 0) {\n      if (runDependencyWatcher !== null) {\n        clearInterval(runDependencyWatcher);\n        runDependencyWatcher = null;\n      }\n      if (dependenciesFulfilled) {\n        var callback = dependenciesFulfilled;\n        dependenciesFulfilled = null;\n        callback();\n      }\n    }\n  }\n\n  Module[\"preloadedImages\"] = {};\n\n  Module[\"preloadedAudios\"] = {};\n\n  function abort(what) {\n    if (Module[\"onAbort\"]) {\n      Module[\"onAbort\"](what);\n    }\n    what += \"\";\n    err(what);\n    ABORT = true;\n    EXITSTATUS = 1;\n    what = \"abort(\" + what + \"). Build with -s ASSERTIONS=1 for more info.\";\n    var e = new WebAssembly.RuntimeError(what);\n    readyPromiseReject(e);\n    throw e;\n  }\n\n  async function createWasm() {\n    const info = {\n      a: asmLibraryArg,\n    };\n    function receiveInstance(instance) {\n      const exports = instance.exports;\n      Module[\"asm\"] = exports;\n      wasmMemory = exports[\"g\"];\n      updateGlobalBufferAndViews(wasmMemory.buffer);\n      wasmTable = exports[\"_\"];\n      addOnInit(exports[\"h\"]);\n      removeRunDependency(\"wasm-instantiate\");\n      return exports;\n    }\n    addRunDependency(\"wasm-instantiate\");\n\n    try {\n      if (Module[\"instantiateWasm\"]) {\n        return await Module[\"instantiateWasm\"](info, receiveInstance);\n      }\n      const result = await WebAssembly.instantiateStreaming(\n        fetch(\"sodium.wasm\", {\n          credentials: \"same-origin\",\n        }),\n        info,\n      );\n      return receiveInstance(result.instance);\n    } catch (e) {\n      try {\n        abort(e);\n      } catch (e) {\n        readyPromiseReject(e);\n      }\n      err(\"Module.instantiateWasm callback failed with error: \" + e);\n      abort(e);\n      return false;\n    }\n  }\n  var tempDouble;\n\n  var tempI64;\n\n  var ASM_CONSTS = {\n    35180: function () {\n      return Module.getRandomValue();\n    },\n    35216: function () {\n      if (Module.getRandomValue === undefined) {\n        Module.getRandomValue = () => {\n          var buf = new Uint32Array(1);\n          crypto.getRandomValues(buf);\n          return buf[0] >>> 0;\n        };\n      }\n    },\n  };\n\n  function callRuntimeCallbacks(callbacks) {\n    while (callbacks.length > 0) {\n      var callback = callbacks.shift();\n      if (typeof callback == \"function\") {\n        callback(Module);\n        continue;\n      }\n      var func = callback.func;\n      if (typeof func === \"number\") {\n        if (callback.arg === undefined) {\n          wasmTable.get(func)();\n        } else {\n          wasmTable.get(func)(callback.arg);\n        }\n      } else {\n        func(callback.arg === undefined ? null : callback.arg);\n      }\n    }\n  }\n\n  function ___assert_fail(condition, filename, line, func) {\n    abort(\n      \"Assertion failed: \" +\n        UTF8ToString(condition) +\n        \", at: \" +\n        [filename ? UTF8ToString(filename) : \"unknown filename\", line, func ? UTF8ToString(func) : \"unknown function\"],\n    );\n  }\n\n  function _abort() {\n    abort();\n  }\n\n  var readAsmConstArgsArray = [];\n\n  function readAsmConstArgs(sigPtr, buf) {\n    readAsmConstArgsArray.length = 0;\n    var ch;\n    buf >>= 2;\n    while ((ch = HEAPU8[sigPtr++])) {\n      var double = ch < 105;\n      if (double && buf & 1) buf++;\n      readAsmConstArgsArray.push(double ? HEAPF64[buf++ >> 1] : HEAP32[buf]);\n      ++buf;\n    }\n    return readAsmConstArgsArray;\n  }\n\n  function _emscripten_asm_const_int(code, sigPtr, argbuf) {\n    var args = readAsmConstArgs(sigPtr, argbuf);\n    return ASM_CONSTS[code].apply(null, args);\n  }\n\n  function _emscripten_get_heap_max() {\n    return 2147483648;\n  }\n\n  function _emscripten_memcpy_big(dest, src, num) {\n    HEAPU8.copyWithin(dest, src, src + num);\n  }\n\n  function emscripten_realloc_buffer(size) {\n    try {\n      wasmMemory.grow((size - buffer.byteLength + 65535) >>> 16);\n      updateGlobalBufferAndViews(wasmMemory.buffer);\n      return 1;\n    } catch (e) {}\n  }\n\n  function _emscripten_resize_heap(requestedSize) {\n    var oldSize = HEAPU8.length;\n    requestedSize = requestedSize >>> 0;\n    var maxHeapSize = 2147483648;\n    if (requestedSize > maxHeapSize) {\n      return false;\n    }\n    for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {\n      var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown);\n      overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296);\n      var newSize = Math.min(maxHeapSize, alignUp(Math.max(requestedSize, overGrownHeapSize), 65536));\n      var replacement = emscripten_realloc_buffer(newSize);\n      if (replacement) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  var asmLibraryArg = {\n    b: ___assert_fail,\n    c: _abort,\n    a: _emscripten_asm_const_int,\n    d: _emscripten_get_heap_max,\n    e: _emscripten_memcpy_big,\n    f: _emscripten_resize_heap,\n  };\n\n  var asm = createWasm();\n\n  var ___wasm_call_ctors = (Module[\"___wasm_call_ctors\"] = function () {\n    return (___wasm_call_ctors = Module[\"___wasm_call_ctors\"] = Module[\"asm\"][\"h\"]).apply(null, arguments);\n  });\n\n  var _crypto_box_publickeybytes = (Module[\"_crypto_box_publickeybytes\"] = function () {\n    return (_crypto_box_publickeybytes = Module[\"_crypto_box_publickeybytes\"] = Module[\"asm\"][\"i\"]).apply(\n      null,\n      arguments,\n    );\n  });\n\n  var _crypto_box_secretkeybytes = (Module[\"_crypto_box_secretkeybytes\"] = function () {\n    return (_crypto_box_secretkeybytes = Module[\"_crypto_box_secretkeybytes\"] = Module[\"asm\"][\"j\"]).apply(\n      null,\n      arguments,\n    );\n  });\n\n  var _crypto_box_noncebytes = (Module[\"_crypto_box_noncebytes\"] = function () {\n    return (_crypto_box_noncebytes = Module[\"_crypto_box_noncebytes\"] = Module[\"asm\"][\"k\"]).apply(null, arguments);\n  });\n\n  var _crypto_box_macbytes = (Module[\"_crypto_box_macbytes\"] = function () {\n    return (_crypto_box_macbytes = Module[\"_crypto_box_macbytes\"] = Module[\"asm\"][\"l\"]).apply(null, arguments);\n  });\n\n  var _crypto_box_easy = (Module[\"_crypto_box_easy\"] = function () {\n    return (_crypto_box_easy = Module[\"_crypto_box_easy\"] = Module[\"asm\"][\"m\"]).apply(null, arguments);\n  });\n\n  var _crypto_box_open_easy = (Module[\"_crypto_box_open_easy\"] = function () {\n    return (_crypto_box_open_easy = Module[\"_crypto_box_open_easy\"] = Module[\"asm\"][\"n\"]).apply(null, arguments);\n  });\n\n  var _crypto_scalarmult_scalarbytes = (Module[\"_crypto_scalarmult_scalarbytes\"] = function () {\n    return (_crypto_scalarmult_scalarbytes = Module[\"_crypto_scalarmult_scalarbytes\"] = Module[\"asm\"][\"o\"]).apply(\n      null,\n      arguments,\n    );\n  });\n\n  var _crypto_secretbox_keybytes = (Module[\"_crypto_secretbox_keybytes\"] = function () {\n    return (_crypto_secretbox_keybytes = Module[\"_crypto_secretbox_keybytes\"] = Module[\"asm\"][\"p\"]).apply(\n      null,\n      arguments,\n    );\n  });\n\n  var _crypto_secretbox_noncebytes = (Module[\"_crypto_secretbox_noncebytes\"] = function () {\n    return (_crypto_secretbox_noncebytes = Module[\"_crypto_secretbox_noncebytes\"] = Module[\"asm\"][\"q\"]).apply(\n      null,\n      arguments,\n    );\n  });\n\n  var _crypto_secretbox_macbytes = (Module[\"_crypto_secretbox_macbytes\"] = function () {\n    return (_crypto_secretbox_macbytes = Module[\"_crypto_secretbox_macbytes\"] = Module[\"asm\"][\"r\"]).apply(\n      null,\n      arguments,\n    );\n  });\n\n  var _crypto_secretbox_easy = (Module[\"_crypto_secretbox_easy\"] = function () {\n    return (_crypto_secretbox_easy = Module[\"_crypto_secretbox_easy\"] = Module[\"asm\"][\"s\"]).apply(null, arguments);\n  });\n\n  var _crypto_secretbox_open_easy = (Module[\"_crypto_secretbox_open_easy\"] = function () {\n    return (_crypto_secretbox_open_easy = Module[\"_crypto_secretbox_open_easy\"] = Module[\"asm\"][\"t\"]).apply(\n      null,\n      arguments,\n    );\n  });\n\n  var _crypto_sign_statebytes = (Module[\"_crypto_sign_statebytes\"] = function () {\n    return (_crypto_sign_statebytes = Module[\"_crypto_sign_statebytes\"] = Module[\"asm\"][\"u\"]).apply(null, arguments);\n  });\n\n  var _crypto_sign_bytes = (Module[\"_crypto_sign_bytes\"] = function () {\n    return (_crypto_sign_bytes = Module[\"_crypto_sign_bytes\"] = Module[\"asm\"][\"v\"]).apply(null, arguments);\n  });\n\n  var _crypto_sign_seedbytes = (Module[\"_crypto_sign_seedbytes\"] = function () {\n    return (_crypto_sign_seedbytes = Module[\"_crypto_sign_seedbytes\"] = Module[\"asm\"][\"w\"]).apply(null, arguments);\n  });\n\n  var _crypto_sign_publickeybytes = (Module[\"_crypto_sign_publickeybytes\"] = function () {\n    return (_crypto_sign_publickeybytes = Module[\"_crypto_sign_publickeybytes\"] = Module[\"asm\"][\"x\"]).apply(\n      null,\n      arguments,\n    );\n  });\n\n  var _crypto_sign_secretkeybytes = (Module[\"_crypto_sign_secretkeybytes\"] = function () {\n    return (_crypto_sign_secretkeybytes = Module[\"_crypto_sign_secretkeybytes\"] = Module[\"asm\"][\"y\"]).apply(\n      null,\n      arguments,\n    );\n  });\n\n  var _crypto_sign_messagebytes_max = (Module[\"_crypto_sign_messagebytes_max\"] = function () {\n    return (_crypto_sign_messagebytes_max = Module[\"_crypto_sign_messagebytes_max\"] = Module[\"asm\"][\"z\"]).apply(\n      null,\n      arguments,\n    );\n  });\n\n  var _crypto_sign_seed_keypair = (Module[\"_crypto_sign_seed_keypair\"] = function () {\n    return (_crypto_sign_seed_keypair = Module[\"_crypto_sign_seed_keypair\"] = Module[\"asm\"][\"A\"]).apply(\n      null,\n      arguments,\n    );\n  });\n\n  var _crypto_sign_keypair = (Module[\"_crypto_sign_keypair\"] = function () {\n    return (_crypto_sign_keypair = Module[\"_crypto_sign_keypair\"] = Module[\"asm\"][\"B\"]).apply(null, arguments);\n  });\n\n  var _crypto_sign = (Module[\"_crypto_sign\"] = function () {\n    return (_crypto_sign = Module[\"_crypto_sign\"] = Module[\"asm\"][\"C\"]).apply(null, arguments);\n  });\n\n  var _crypto_sign_open = (Module[\"_crypto_sign_open\"] = function () {\n    return (_crypto_sign_open = Module[\"_crypto_sign_open\"] = Module[\"asm\"][\"D\"]).apply(null, arguments);\n  });\n\n  var _crypto_sign_detached = (Module[\"_crypto_sign_detached\"] = function () {\n    return (_crypto_sign_detached = Module[\"_crypto_sign_detached\"] = Module[\"asm\"][\"E\"]).apply(null, arguments);\n  });\n\n  var _crypto_sign_verify_detached = (Module[\"_crypto_sign_verify_detached\"] = function () {\n    return (_crypto_sign_verify_detached = Module[\"_crypto_sign_verify_detached\"] = Module[\"asm\"][\"F\"]).apply(\n      null,\n      arguments,\n    );\n  });\n\n  var _crypto_sign_init = (Module[\"_crypto_sign_init\"] = function () {\n    return (_crypto_sign_init = Module[\"_crypto_sign_init\"] = Module[\"asm\"][\"G\"]).apply(null, arguments);\n  });\n\n  var _crypto_sign_update = (Module[\"_crypto_sign_update\"] = function () {\n    return (_crypto_sign_update = Module[\"_crypto_sign_update\"] = Module[\"asm\"][\"H\"]).apply(null, arguments);\n  });\n\n  var _crypto_sign_final_create = (Module[\"_crypto_sign_final_create\"] = function () {\n    return (_crypto_sign_final_create = Module[\"_crypto_sign_final_create\"] = Module[\"asm\"][\"I\"]).apply(\n      null,\n      arguments,\n    );\n  });\n\n  var _crypto_sign_final_verify = (Module[\"_crypto_sign_final_verify\"] = function () {\n    return (_crypto_sign_final_verify = Module[\"_crypto_sign_final_verify\"] = Module[\"asm\"][\"J\"]).apply(\n      null,\n      arguments,\n    );\n  });\n\n  var _crypto_sign_ed25519_pk_to_curve25519 = (Module[\"_crypto_sign_ed25519_pk_to_curve25519\"] = function () {\n    return (_crypto_sign_ed25519_pk_to_curve25519 = Module[\"_crypto_sign_ed25519_pk_to_curve25519\"] =\n      Module[\"asm\"][\"K\"]).apply(null, arguments);\n  });\n\n  var _crypto_sign_ed25519_sk_to_curve25519 = (Module[\"_crypto_sign_ed25519_sk_to_curve25519\"] = function () {\n    return (_crypto_sign_ed25519_sk_to_curve25519 = Module[\"_crypto_sign_ed25519_sk_to_curve25519\"] =\n      Module[\"asm\"][\"L\"]).apply(null, arguments);\n  });\n\n  var _randombytes_random = (Module[\"_randombytes_random\"] = function () {\n    return (_randombytes_random = Module[\"_randombytes_random\"] = Module[\"asm\"][\"M\"]).apply(null, arguments);\n  });\n\n  var _randombytes_stir = (Module[\"_randombytes_stir\"] = function () {\n    return (_randombytes_stir = Module[\"_randombytes_stir\"] = Module[\"asm\"][\"N\"]).apply(null, arguments);\n  });\n\n  var _randombytes_uniform = (Module[\"_randombytes_uniform\"] = function () {\n    return (_randombytes_uniform = Module[\"_randombytes_uniform\"] = Module[\"asm\"][\"O\"]).apply(null, arguments);\n  });\n\n  var _randombytes_buf = (Module[\"_randombytes_buf\"] = function () {\n    return (_randombytes_buf = Module[\"_randombytes_buf\"] = Module[\"asm\"][\"P\"]).apply(null, arguments);\n  });\n\n  var _randombytes_buf_deterministic = (Module[\"_randombytes_buf_deterministic\"] = function () {\n    return (_randombytes_buf_deterministic = Module[\"_randombytes_buf_deterministic\"] = Module[\"asm\"][\"Q\"]).apply(\n      null,\n      arguments,\n    );\n  });\n\n  var _randombytes_seedbytes = (Module[\"_randombytes_seedbytes\"] = function () {\n    return (_randombytes_seedbytes = Module[\"_randombytes_seedbytes\"] = Module[\"asm\"][\"R\"]).apply(null, arguments);\n  });\n\n  var _randombytes_close = (Module[\"_randombytes_close\"] = function () {\n    return (_randombytes_close = Module[\"_randombytes_close\"] = Module[\"asm\"][\"S\"]).apply(null, arguments);\n  });\n\n  var _randombytes = (Module[\"_randombytes\"] = function () {\n    return (_randombytes = Module[\"_randombytes\"] = Module[\"asm\"][\"T\"]).apply(null, arguments);\n  });\n\n  var _sodium_bin2hex = (Module[\"_sodium_bin2hex\"] = function () {\n    return (_sodium_bin2hex = Module[\"_sodium_bin2hex\"] = Module[\"asm\"][\"U\"]).apply(null, arguments);\n  });\n\n  var _sodium_hex2bin = (Module[\"_sodium_hex2bin\"] = function () {\n    return (_sodium_hex2bin = Module[\"_sodium_hex2bin\"] = Module[\"asm\"][\"V\"]).apply(null, arguments);\n  });\n\n  var _sodium_base64_encoded_len = (Module[\"_sodium_base64_encoded_len\"] = function () {\n    return (_sodium_base64_encoded_len = Module[\"_sodium_base64_encoded_len\"] = Module[\"asm\"][\"W\"]).apply(\n      null,\n      arguments,\n    );\n  });\n\n  var _sodium_bin2base64 = (Module[\"_sodium_bin2base64\"] = function () {\n    return (_sodium_bin2base64 = Module[\"_sodium_bin2base64\"] = Module[\"asm\"][\"X\"]).apply(null, arguments);\n  });\n\n  var _sodium_base642bin = (Module[\"_sodium_base642bin\"] = function () {\n    return (_sodium_base642bin = Module[\"_sodium_base642bin\"] = Module[\"asm\"][\"Y\"]).apply(null, arguments);\n  });\n\n  var _sodium_init = (Module[\"_sodium_init\"] = function () {\n    return (_sodium_init = Module[\"_sodium_init\"] = Module[\"asm\"][\"Z\"]).apply(null, arguments);\n  });\n\n  var _sodium_pad = (Module[\"_sodium_pad\"] = function () {\n    return (_sodium_pad = Module[\"_sodium_pad\"] = Module[\"asm\"][\"_\"]).apply(null, arguments);\n  });\n\n  var _sodium_unpad = (Module[\"_sodium_unpad\"] = function () {\n    return (_sodium_unpad = Module[\"_sodium_unpad\"] = Module[\"asm\"][\"$\"]).apply(null, arguments);\n  });\n\n  var _sodium_version_string = (Module[\"_sodium_version_string\"] = function () {\n    return (_sodium_version_string = Module[\"_sodium_version_string\"] = Module[\"asm\"][\"aa\"]).apply(null, arguments);\n  });\n\n  var _sodium_library_version_major = (Module[\"_sodium_library_version_major\"] = function () {\n    return (_sodium_library_version_major = Module[\"_sodium_library_version_major\"] = Module[\"asm\"][\"ba\"]).apply(\n      null,\n      arguments,\n    );\n  });\n\n  var _sodium_library_version_minor = (Module[\"_sodium_library_version_minor\"] = function () {\n    return (_sodium_library_version_minor = Module[\"_sodium_library_version_minor\"] = Module[\"asm\"][\"ca\"]).apply(\n      null,\n      arguments,\n    );\n  });\n\n  var _sodium_library_minimal = (Module[\"_sodium_library_minimal\"] = function () {\n    return (_sodium_library_minimal = Module[\"_sodium_library_minimal\"] = Module[\"asm\"][\"da\"]).apply(null, arguments);\n  });\n\n  var _malloc = (Module[\"_malloc\"] = function () {\n    return (_malloc = Module[\"_malloc\"] = Module[\"asm\"][\"ea\"]).apply(null, arguments);\n  });\n\n  var _free = (Module[\"_free\"] = function () {\n    return (_free = Module[\"_free\"] = Module[\"asm\"][\"fa\"]).apply(null, arguments);\n  });\n\n  Module[\"setValue\"] = setValue;\n\n  Module[\"getValue\"] = getValue;\n\n  Module[\"UTF8ToString\"] = UTF8ToString;\n\n  var calledRun;\n\n  dependenciesFulfilled = function runCaller() {\n    if (!calledRun) run();\n    if (!calledRun) dependenciesFulfilled = runCaller;\n  };\n\n  function run(args) {\n    if (runDependencies > 0) {\n      return;\n    }\n    preRun();\n    if (runDependencies > 0) {\n      return;\n    }\n    function doRun() {\n      if (calledRun) return;\n      calledRun = true;\n      Module[\"calledRun\"] = true;\n      if (ABORT) return;\n      initRuntime();\n      readyPromiseResolve(Module);\n      if (Module[\"onRuntimeInitialized\"]) Module[\"onRuntimeInitialized\"]();\n      postRun();\n    }\n    if (Module[\"setStatus\"]) {\n      Module[\"setStatus\"](\"Running...\");\n      setTimeout(function () {\n        setTimeout(function () {\n          Module[\"setStatus\"](\"\");\n        }, 1);\n        doRun();\n      }, 1);\n    } else {\n      doRun();\n    }\n  }\n\n  Module[\"run\"] = run;\n\n  if (Module[\"preInit\"]) {\n    if (typeof Module[\"preInit\"] == \"function\") Module[\"preInit\"] = [Module[\"preInit\"]];\n    while (Module[\"preInit\"].length > 0) {\n      Module[\"preInit\"].pop()();\n    }\n  }\n\n  run();\n\n  return Module.ready;\n};\n\nexport default libsodiumModule;\n","import libsodiumInstaller from \"./libsodium\";\nimport type { LibsodiumModule, Optional, InstantiateWasm } from \"./libsodium\";\n\nexport const libsodium = {} as LibsodiumModule;\n\nconst output_format = \"uint8array\";\n\nlet _installRes: Promise<InstallOptions | void> | undefined;\nexport type InstallOptions = {\n  instantiateWasm?: InstantiateWasm;\n  getRandomValue?: () => number;\n};\nexport const install = (options?: InstallOptions) => {\n  return _installRes || (_installRes = _install(options));\n};\nconst _install = async (options?: InstallOptions) => {\n  if (options) {\n    libsodium.instantiateWasm = options.instantiateWasm;\n    options.getRandomValue && (libsodium.getRandomValue = options.getRandomValue);\n  }\n  libsodiumInstaller(libsodium);\n\n  await libsodium.ready;\n  /* Test to make sure everything works.*/\n  try {\n    if (libsodium._sodium_init() !== 0) {\n      throw new Error(\"libsodium was not correctly initialized.\");\n    }\n    const message = new Uint8Array([98, 97, 108, 108, 115]);\n    const nonce = randombytes_buf(CONSTANTS.crypto_secretbox_NONCEBYTES);\n    const key = randombytes_buf(CONSTANTS.crypto_secretbox_KEYBYTES);\n    const encrypted = crypto_secretbox_easy(message, nonce, key);\n    const decrypted = crypto_secretbox_open_easy(encrypted, nonce, key);\n\n    if (memcmp(message, decrypted)) {\n      return options;\n    }\n  } catch (err) {\n    console.log(err);\n    throw new Error(\"./libsodium.js wasm failed to load\" + err);\n  }\n};\n\n// List of functions and constants defined in the wrapped libsodium\nfunction symbols() {\n  return [\n    // \"libsodium\",\n    // \"ready\",\n    // \"symbols\",\n    // \"increment\",\n    // \"add\",\n    // \"is_zero\",\n    // \"memzero\",\n    // \"memcmp\",\n    // \"compare\",\n    // \"pad\",\n    // \"unpad\",\n    // \"from_string\",\n    // \"to_string\",\n    // \"from_hex\",\n    // \"to_hex\",\n    // \"base64_variants\",\n    // \"from_base64\",\n    // \"to_base64\",\n    // \"output_formats\",\n    \"crypto_box_easy\",\n    \"crypto_box_open_easy\",\n    \"crypto_secretbox_easy\",\n    \"crypto_secretbox_open_easy\",\n    \"crypto_sign\",\n    \"crypto_sign_detached\",\n    \"crypto_sign_ed25519_pk_to_curve25519\",\n    \"crypto_sign_ed25519_sk_to_curve25519\",\n    \"crypto_sign_final_create\",\n    \"crypto_sign_final_verify\",\n    \"crypto_sign_init\",\n    \"crypto_sign_keypair\",\n    \"crypto_sign_open\",\n    \"crypto_sign_seed_keypair\",\n    \"crypto_sign_update\",\n    \"crypto_sign_verify_detached\",\n    \"randombytes_buf\",\n    \"randombytes_buf_deterministic\",\n    \"randombytes_close\",\n    \"randombytes_random\",\n    \"randombytes_stir\",\n    \"randombytes_uniform\",\n    \"sodium_version_string\",\n    \"SODIUM_LIBRARY_VERSION_MAJOR\",\n    \"SODIUM_LIBRARY_VERSION_MINOR\",\n    \"SODIUM_VERSION_STRING\",\n    \"crypto_box_MACBYTES\",\n    \"crypto_box_NONCEBYTES\",\n    \"crypto_box_PUBLICKEYBYTES\",\n    \"crypto_box_SECRETKEYBYTES\",\n    \"crypto_scalarmult_SCALARBYTES\",\n    \"crypto_secretbox_KEYBYTES\",\n    \"crypto_secretbox_MACBYTES\",\n    \"crypto_secretbox_NONCEBYTES\",\n    \"crypto_sign_BYTES\",\n    \"crypto_sign_MESSAGEBYTES_MAX\",\n    \"crypto_sign_PUBLICKEYBYTES\",\n    \"crypto_sign_SECRETKEYBYTES\",\n    \"crypto_sign_SEEDBYTES\",\n  ];\n}\n\nfunction increment(bytes: Uint8Array) {\n  if (!(bytes instanceof Uint8Array)) {\n    throw new TypeError(\"Only Uint8Array instances can be incremented\");\n  }\n  var c = 1 << 8;\n  for (var i = 0 | 0, j = bytes.length; i < j; i++) {\n    c >>= 8;\n    c += bytes[i];\n    bytes[i] = c & 0xff;\n  }\n}\n\nfunction add(a: Uint8Array, b: Uint8Array) {\n  if (!(a instanceof Uint8Array) || !(b instanceof Uint8Array)) {\n    throw new TypeError(\"Only Uint8Array instances can added\");\n  }\n  var j = a.length,\n    c = 0 | 0,\n    i = 0 | 0;\n  if (b.length != a.length) {\n    throw new TypeError(\"Arguments must have the same length\");\n  }\n  for (i = 0; i < j; i++) {\n    c >>= 8;\n    c += a[i] + b[i];\n    a[i] = c & 0xff;\n  }\n}\n\nfunction is_zero(bytes: Uint8Array) {\n  if (!(bytes instanceof Uint8Array)) {\n    throw new TypeError(\"Only Uint8Array instances can be checked\");\n  }\n  var d = 0 | 0;\n  for (var i = 0 | 0, j = bytes.length; i < j; i++) {\n    d |= bytes[i];\n  }\n  return d === 0;\n}\n\nfunction memzero(bytes: Uint8Array) {\n  if (!(bytes instanceof Uint8Array)) {\n    throw new TypeError(\"Only Uint8Array instances can be wiped\");\n  }\n  for (var i = 0 | 0, j = bytes.length; i < j; i++) {\n    bytes[i] = 0;\n  }\n}\n\nfunction memcmp(b1: Uint8Array, b2: Uint8Array) {\n  if (!(b1 instanceof Uint8Array && b2 instanceof Uint8Array)) {\n    throw new TypeError(\"Only Uint8Array instances can be compared\");\n  }\n  if (b1.length !== b2.length) {\n    throw new TypeError(\"Only instances of identical length can be compared\");\n  }\n  for (var d = 0 | 0, i = 0 | 0, j = b1.length; i < j; i++) {\n    d |= b1[i] ^ b2[i];\n  }\n  return d === 0;\n}\n\nfunction compare(b1: Uint8Array, b2: Uint8Array) {\n  if (!(b1 instanceof Uint8Array && b2 instanceof Uint8Array)) {\n    throw new TypeError(\"Only Uint8Array instances can be compared\");\n  }\n  if (b1.length !== b2.length) {\n    throw new TypeError(\"Only instances of identical length can be compared\");\n  }\n  for (var gt = 0 | 0, eq = 1 | 1, i = b1.length; i-- > 0; ) {\n    gt |= ((b2[i] - b1[i]) >> 8) & eq;\n    eq &= ((b2[i] ^ b1[i]) - 1) >> 8;\n  }\n  return gt + gt + eq - 1;\n}\n\nfunction pad(buf: Uint8Array, blocksize: number) {\n  if (!(buf instanceof Uint8Array)) {\n    throw new TypeError(\"buffer must be a Uint8Array\");\n  }\n  blocksize |= 0;\n  if (blocksize <= 0) {\n    throw new Error(\"block size must be > 0\");\n  }\n  var address_pool = [],\n    padded,\n    padded_buflen_p = _malloc(4),\n    st = 1 | 0,\n    i = 0 | 0,\n    k = buf.length | 0,\n    bufx = new AllocatedBuf(k + blocksize);\n  address_pool.push(padded_buflen_p);\n  address_pool.push(bufx.address);\n  for (var j = bufx.address, jmax = bufx.address + k + blocksize; j < jmax; j++) {\n    libsodium.HEAPU8[j] = buf[i];\n    k -= st;\n    st = ~(((((k >>> 48) | (k >>> 32) | (k >>> 16) | k) & 0xffff) - 1) >> 16) & 1;\n    i += st;\n  }\n  if (libsodium._sodium_pad(padded_buflen_p, bufx.address, buf.length, blocksize, bufx.length) !== 0) {\n    _free_and_throw_error(address_pool, \"internal error\");\n  }\n  bufx.length = libsodium.getValue(padded_buflen_p, \"i32\");\n  padded = bufx.to_Uint8Array();\n  _free_all(address_pool);\n  return padded;\n}\n\nfunction unpad(buf: Uint8Array, blocksize: number) {\n  if (!(buf instanceof Uint8Array)) {\n    throw new TypeError(\"buffer must be a Uint8Array\");\n  }\n  blocksize |= 0;\n  if (blocksize <= 0) {\n    throw new Error(\"block size must be > 0\");\n  }\n  var address_pool = [],\n    unpadded_address = _to_allocated_buf_address(buf),\n    unpadded_buflen_p = _malloc(4);\n  address_pool.push(unpadded_address);\n  address_pool.push(unpadded_buflen_p);\n  if (libsodium._sodium_unpad(unpadded_buflen_p, unpadded_address, buf.length, blocksize) !== 0) {\n    _free_and_throw_error(address_pool, \"unsupported/invalid padding\");\n  }\n  buf = new Uint8Array(buf);\n  buf = buf.subarray(0, libsodium.getValue(unpadded_buflen_p, \"i32\"));\n  _free_all(address_pool);\n  return buf;\n}\n\n//---------------------------------------------------------------------------\n// Codecs\n//\nconst dec = new TextEncoder();\nexport const from_string = dec.encode.bind(dec);\n\nconst enc = new TextDecoder(\"utf-8\", {\n  fatal: true,\n});\nexport const to_string = enc.decode.bind(enc);\n\nexport function from_hex(input: string) {\n  const address_pool = new AddressPool();\n  const inputU8 = _any_to_Uint8Array(address_pool, input, \"input\");\n  const result = new AllocatedBuf(inputU8.length / 2);\n  const input_address = _to_allocated_buf_address(inputU8);\n  const hex_end_p = _malloc(4);\n  address_pool.push(input_address);\n  address_pool.push(result.address);\n  address_pool.push(hex_end_p);\n  if (libsodium._sodium_hex2bin(result.address, result.length, input_address, inputU8.length, 0, 0, hex_end_p) !== 0) {\n    _free_and_throw_error(address_pool, \"invalid input\");\n  }\n  const hex_end = libsodium.getValue(hex_end_p, \"i32\");\n  if (hex_end - input_address !== inputU8.length) {\n    _free_and_throw_error(address_pool, \"incomplete input\");\n  }\n  const result_str = result.to_Uint8Array();\n  _free_all(address_pool);\n  return result_str;\n}\n\nexport function to_hex(input: Uint8Array) {\n  input = _any_to_Uint8Array(null, input, \"input\");\n  var str = \"\",\n    b,\n    c,\n    x;\n  for (var i = 0; i < input.length; i++) {\n    c = input[i] & 0xf;\n    b = input[i] >>> 4;\n    x = ((87 + c + (((c - 10) >> 8) & ~38)) << 8) | (87 + b + (((b - 10) >> 8) & ~38));\n    str += String.fromCharCode(x & 0xff) + String.fromCharCode(x >>> 8);\n  }\n  return str;\n}\n\nexport enum base64_variants {\n  ORIGINAL = 1 | 0,\n  ORIGINAL_NO_PADDING = 3 | 0,\n  URLSAFE = 5 | 0,\n  URLSAFE_NO_PADDING = 7 | 0,\n}\n\nfunction check_base64_variant<T extends unknown>(variant: T | undefined) {\n  if (variant == undefined) {\n    return base64_variants.URLSAFE_NO_PADDING;\n  }\n  if (\n    variant !== base64_variants.ORIGINAL &&\n    variant !== base64_variants.ORIGINAL_NO_PADDING &&\n    variant !== base64_variants.URLSAFE &&\n    variant != base64_variants.URLSAFE_NO_PADDING\n  ) {\n    throw new Error(\"unsupported base64 variant\");\n  }\n  return variant;\n}\n\nexport function from_base64(input: string, variant?: base64_variants) {\n  variant = check_base64_variant(variant);\n  const address_pool = new AddressPool();\n  const inputU8 = _any_to_Uint8Array(address_pool, input, \"input\");\n  const result = new AllocatedBuf((inputU8.length * 3) / 4);\n  const input_address = _to_allocated_buf_address(inputU8);\n  const result_bin_len_p = _malloc(4);\n  const b64_end_p = _malloc(4);\n  address_pool.push(input_address);\n  address_pool.push(result.address);\n  address_pool.push(result_bin_len_p);\n  address_pool.push(b64_end_p);\n  if (\n    libsodium._sodium_base642bin(\n      result.address,\n      result.length,\n      input_address,\n      inputU8.length,\n      0,\n      result_bin_len_p,\n      b64_end_p,\n      variant,\n    ) !== 0\n  ) {\n    _free_and_throw_error(address_pool, \"invalid input\");\n  }\n  const b64_end = libsodium.getValue(b64_end_p, \"i32\");\n  if (b64_end - input_address !== inputU8.length) {\n    _free_and_throw_error(address_pool, \"incomplete input\");\n  }\n  result.length = libsodium.getValue(result_bin_len_p, \"i32\");\n  const result_bin = result.to_Uint8Array();\n  _free_all(address_pool);\n  return result_bin;\n}\n\nexport function to_base64(input: Uint8Array, variant?: base64_variants) {\n  variant = check_base64_variant(variant);\n  const address_pool = new AddressPool();\n  input = _any_to_Uint8Array(address_pool, input, \"input\");\n  const nibbles = Math.floor(input.length / 3) | 0;\n  const remainder = input.length - 3 * nibbles;\n  const b64_len = nibbles * 4 + (remainder !== 0 ? ((variant & 2) === 0 ? 4 : 2 + (remainder >>> 1)) : 0);\n  const result = new AllocatedBuf(b64_len + 1);\n  const input_address = _to_allocated_buf_address(input);\n  address_pool.push(input_address);\n  address_pool.push(result.address);\n  if (libsodium._sodium_bin2base64(result.address, result.length, input_address, input.length, variant) === 0) {\n    _free_and_throw_error(address_pool, \"conversion failed\");\n  }\n  result.length = b64_len;\n  const result_b64 = to_string(result.to_Uint8Array());\n  _free_all(address_pool);\n  return result_b64;\n}\n\nexport const output_formats = Object.freeze([\"uint8array\", \"text\", \"hex\", \"base64\"]);\n\nnamespace FormatReturn {\n  export type Types = uint8array_type | undefined_type | text_type | hex_type | base64_type;\n  export type Name<T> = T extends BaseType<infer F, infer _> ? F : never;\n  export type GetReturn<F, T> = T extends BaseType<infer Format, infer O> ? (F extends Format ? O : never) : never;\n  type BaseType<F, O> = [F, O];\n  type uint8array_type = BaseType<\"uint8array\", Uint8Array>;\n  type undefined_type = BaseType<undefined, Uint8Array>;\n  type text_type = BaseType<\"text\", string>;\n  type hex_type = BaseType<\"hex\", string>;\n  type base64_type = BaseType<\"base64\", string>;\n}\ntype FormatReturnNames = FormatReturn.Name<FormatReturn.Types>;\n\nfunction _format_output<F extends FormatReturnNames>(\n  output: AllocatedBuf,\n  optionalOutputFormat: F,\n): FormatReturn.GetReturn<F, FormatReturn.Types> {\n  var selectedOutputFormat = optionalOutputFormat || output_format;\n  if (!_is_output_format(selectedOutputFormat)) {\n    throw new Error(selectedOutputFormat + \" output format is not available\");\n  }\n  if (output instanceof AllocatedBuf) {\n    if (selectedOutputFormat === \"uint8array\") {\n      return output.to_Uint8Array() as FormatReturn.GetReturn<F, FormatReturn.Types>;\n    } else if (selectedOutputFormat === \"text\") {\n      return to_string(output.to_Uint8Array()) as FormatReturn.GetReturn<F, FormatReturn.Types>;\n    } else if (selectedOutputFormat === \"hex\") {\n      return to_hex(output.to_Uint8Array()) as FormatReturn.GetReturn<F, FormatReturn.Types>;\n    } else if (selectedOutputFormat === \"base64\") {\n      return to_base64(output.to_Uint8Array(), base64_variants.URLSAFE_NO_PADDING) as FormatReturn.GetReturn<\n        F,\n        FormatReturn.Types\n      >;\n    }\n    throw new Error('What is output format \"' + selectedOutputFormat + '\"?');\n  }\n\n  throw new TypeError(\"Cannot format output\");\n}\n// function _format_multi_output(_format_output:{ [type: string]: AllocatedBuf } | string){}\n\nfunction _is_output_format(format: unknown) {\n  return output_formats.includes(format as never);\n}\n\nfunction _check_output_format(format?: string) {\n  if (!format) {\n    return;\n  } else if (typeof format !== \"string\") {\n    throw new TypeError(\"When defined, the output format must be a string\");\n  } else if (!_is_output_format(format)) {\n    throw new Error(format + \" is not a supported output format\");\n  }\n}\n\n//---------------------------------------------------------------------------\n// Memory management\n//\n// AllocatedBuf: address allocated using _malloc() + length\nclass AllocatedBuf {\n  constructor(public /* readonly */ length: number) {\n    this.address = _malloc(length);\n  }\n  public readonly address: number;\n  /**Copy the content of a AllocatedBuf (_malloc()'d memory) into a Uint8Array */\n  to_Uint8Array() {\n    var result = new Uint8Array(this.length);\n    result.set(libsodium.HEAPU8.subarray(this.address, this.address + this.length));\n    return result;\n  }\n}\nclass AddressPool extends Array<number> {\n  push(add: number) {\n    return (this[this.length] = add);\n  }\n}\n\n// _malloc() a region and initialize it with the content of a Uint8Array\nfunction _to_allocated_buf_address(bytes: Uint8Array) {\n  var address = _malloc(bytes.length);\n  libsodium.HEAPU8.set(bytes, address);\n  return address;\n}\n\nfunction _malloc(length: number) {\n  var result = libsodium._malloc(length);\n  if (result === 0) {\n    throw {\n      message: \"_malloc() failed\",\n      length: length,\n    };\n  }\n  return result;\n}\n\nfunction _free(address: number) {\n  libsodium._free(address);\n}\n\nfunction _free_all(addresses: AddressPool | null) {\n  if (addresses) {\n    for (var i = 0; i < addresses.length; i++) {\n      _free(addresses[i]);\n    }\n  }\n}\n\nfunction _free_and_throw_error(address_pool: AddressPool | null, err: string): never {\n  _free_all(address_pool);\n  throw new Error(err);\n}\n\nfunction _free_and_throw_type_error(address_pool: AddressPool | null, err: string): never {\n  _free_all(address_pool);\n  throw new TypeError(err);\n}\n\nfunction _require_defined(address_pool: AddressPool | null, varValue: unknown, varName: string) {\n  if (varValue == undefined) {\n    _free_and_throw_type_error(address_pool, varName + \" cannot be null or undefined\");\n  }\n}\n\nfunction _any_to_Uint8Array(address_pool: AddressPool | null, varValue: Uint8Array | string, varName: string) {\n  _require_defined(address_pool, varValue, varName);\n  if (varValue instanceof Uint8Array) {\n    return varValue;\n  } else if (typeof varValue === \"string\") {\n    return from_string(varValue);\n  }\n  _free_and_throw_type_error(address_pool, \"unsupported input type for \" + varName);\n}\n\nconst _cacheDefineConstantsProp = (key: string, value: number) => {\n  Object.defineProperty(CONSTANTS, key, {\n    value,\n    writable: false,\n    configurable: true,\n    enumerable: true,\n  });\n};\nexport const CONSTANTS = {\n  get SODIUM_LIBRARY_VERSION_MAJOR() {\n    const constantsValue = libsodium._sodium_library_version_major();\n    _cacheDefineConstantsProp(\"SODIUM_LIBRARY_VERSION_MAJOR\", constantsValue);\n    return constantsValue;\n  },\n  get SODIUM_LIBRARY_VERSION_MINOR() {\n    const constantsValue = libsodium._sodium_library_version_minor();\n    _cacheDefineConstantsProp(\"SODIUM_LIBRARY_VERSION_MINOR\", constantsValue);\n    return constantsValue;\n  },\n  get SODIUM_VERSION_STRING() {\n    const constantsValue = libsodium._sodium_version_string();\n    _cacheDefineConstantsProp(\"SODIUM_VERSION_STRING\", constantsValue);\n    return constantsValue;\n  },\n  get crypto_box_MACBYTES() {\n    const constantsValue = libsodium._crypto_box_macbytes();\n    _cacheDefineConstantsProp(\"crypto_box_MACBYTES\", constantsValue);\n    return constantsValue;\n  },\n  get crypto_box_NONCEBYTES() {\n    const constantsValue = libsodium._crypto_box_noncebytes();\n    _cacheDefineConstantsProp(\"crypto_box_NONCEBYTES\", constantsValue);\n    return constantsValue;\n  },\n  get crypto_box_PUBLICKEYBYTES() {\n    const constantsValue = libsodium._crypto_box_publickeybytes();\n    _cacheDefineConstantsProp(\"crypto_box_PUBLICKEYBYTES\", constantsValue);\n    return constantsValue;\n  },\n  get crypto_box_SECRETKEYBYTES() {\n    const constantsValue = libsodium._crypto_box_secretkeybytes();\n    _cacheDefineConstantsProp(\"crypto_box_SECRETKEYBYTES\", constantsValue);\n    return constantsValue;\n  },\n  get crypto_scalarmult_SCALARBYTES() {\n    const constantsValue = libsodium._crypto_scalarmult_scalarbytes();\n    _cacheDefineConstantsProp(\"crypto_scalarmult_SCALARBYTES\", constantsValue);\n    return constantsValue;\n  },\n  get crypto_secretbox_KEYBYTES() {\n    const constantsValue = libsodium._crypto_secretbox_keybytes();\n    _cacheDefineConstantsProp(\"crypto_secretbox_KEYBYTES\", constantsValue);\n    return constantsValue;\n  },\n  get crypto_secretbox_MACBYTES() {\n    const constantsValue = libsodium._crypto_secretbox_macbytes();\n    _cacheDefineConstantsProp(\"crypto_secretbox_MACBYTES\", constantsValue);\n    return constantsValue;\n  },\n  get crypto_secretbox_NONCEBYTES() {\n    const constantsValue = libsodium._crypto_secretbox_noncebytes();\n    _cacheDefineConstantsProp(\"crypto_secretbox_NONCEBYTES\", constantsValue);\n    return constantsValue;\n  },\n  get crypto_sign_BYTES() {\n    const constantsValue = libsodium._crypto_sign_bytes();\n    _cacheDefineConstantsProp(\"crypto_sign_BYTES\", constantsValue);\n    return constantsValue;\n  },\n  get crypto_sign_MESSAGEBYTES_MAX() {\n    const constantsValue = libsodium._crypto_sign_messagebytes_max();\n    _cacheDefineConstantsProp(\"crypto_sign_MESSAGEBYTES_MAX\", constantsValue);\n    return constantsValue;\n  },\n  get crypto_sign_PUBLICKEYBYTES() {\n    const constantsValue = libsodium._crypto_sign_publickeybytes();\n    _cacheDefineConstantsProp(\"crypto_sign_PUBLICKEYBYTES\", constantsValue);\n    return constantsValue;\n  },\n  get crypto_sign_SECRETKEYBYTES() {\n    const constantsValue = libsodium._crypto_sign_secretkeybytes();\n    _cacheDefineConstantsProp(\"crypto_sign_SECRETKEYBYTES\", constantsValue);\n    return constantsValue;\n  },\n  get crypto_sign_SEEDBYTES() {\n    const constantsValue = libsodium._crypto_sign_seedbytes();\n    _cacheDefineConstantsProp(\"crypto_sign_SEEDBYTES\", constantsValue);\n    return constantsValue;\n  },\n};\nexport const crypto_box_easy = <T extends FormatReturnNames = \"uint8array\">(\n  message: Uint8Array,\n  nonce: Uint8Array,\n  publicKey: Uint8Array,\n  privateKey: Uint8Array,\n  outputFormat: T = \"uint8array\" as T,\n) => {\n  const address_pool = new AddressPool();\n\n  _check_output_format(outputFormat);\n  // ---------- input: message (unsized_buf)\n\n  message = _any_to_Uint8Array(address_pool, message, \"message\");\n  var message_address = _to_allocated_buf_address(message),\n    message_length = message.length;\n  address_pool.push(message_address);\n\n  // ---------- input: nonce (buf)\n\n  nonce = _any_to_Uint8Array(address_pool, nonce, \"nonce\");\n  var nonce_address,\n    nonce_length = libsodium._crypto_box_noncebytes() | 0;\n  if (nonce.length !== nonce_length) {\n    _free_and_throw_type_error(address_pool, \"invalid nonce length\");\n  }\n  nonce_address = _to_allocated_buf_address(nonce);\n  address_pool.push(nonce_address);\n\n  // ---------- input: publicKey (buf)\n\n  publicKey = _any_to_Uint8Array(address_pool, publicKey, \"publicKey\");\n  var publicKey_address,\n    publicKey_length = libsodium._crypto_box_publickeybytes() | 0;\n  if (publicKey.length !== publicKey_length) {\n    _free_and_throw_type_error(address_pool, \"invalid publicKey length\");\n  }\n  publicKey_address = _to_allocated_buf_address(publicKey);\n  address_pool.push(publicKey_address);\n\n  // ---------- input: privateKey (buf)\n\n  privateKey = _any_to_Uint8Array(address_pool, privateKey, \"privateKey\");\n  var privateKey_address,\n    privateKey_length = libsodium._crypto_box_secretkeybytes() | 0;\n  if (privateKey.length !== privateKey_length) {\n    _free_and_throw_type_error(address_pool, \"invalid privateKey length\");\n  }\n  privateKey_address = _to_allocated_buf_address(privateKey);\n  address_pool.push(privateKey_address);\n\n  // ---------- output ciphertext (buf)\n\n  var ciphertext_length = (message_length + libsodium._crypto_box_macbytes()) | 0,\n    ciphertext = new AllocatedBuf(ciphertext_length),\n    ciphertext_address = ciphertext.address;\n\n  address_pool.push(ciphertext_address);\n\n  if (\n    (libsodium._crypto_box_easy(\n      ciphertext_address,\n      message_address,\n      message_length,\n      0,\n      nonce_address,\n      publicKey_address,\n      privateKey_address,\n    ) |\n      0) ===\n    0\n  ) {\n    var ret = _format_output(ciphertext, outputFormat);\n    _free_all(address_pool);\n    return ret;\n  }\n  _free_and_throw_error(address_pool, \"invalid usage\");\n};\n\nexport const crypto_box_open_easy = <T extends FormatReturnNames = \"uint8array\">(\n  ciphertext: Uint8Array,\n  nonce: Uint8Array,\n  publicKey: Uint8Array,\n  privateKey: Uint8Array,\n  outputFormat: T = \"uint8array\" as T,\n) => {\n  const address_pool = new AddressPool();\n\n  _check_output_format(outputFormat);\n  // ---------- input: ciphertext (minsized_buf)\n\n  ciphertext = _any_to_Uint8Array(address_pool, ciphertext, \"ciphertext\");\n  var ciphertext_address,\n    ciphertext_min_length = libsodium._crypto_box_macbytes(),\n    ciphertext_length = ciphertext.length;\n  if (ciphertext_length < ciphertext_min_length) {\n    _free_and_throw_type_error(address_pool, \"ciphertext is too short\");\n  }\n  ciphertext_address = _to_allocated_buf_address(ciphertext);\n  address_pool.push(ciphertext_address);\n\n  // ---------- input: nonce (buf)\n\n  nonce = _any_to_Uint8Array(address_pool, nonce, \"nonce\");\n  var nonce_address,\n    nonce_length = libsodium._crypto_box_noncebytes() | 0;\n  if (nonce.length !== nonce_length) {\n    _free_and_throw_type_error(address_pool, \"invalid nonce length\");\n  }\n  nonce_address = _to_allocated_buf_address(nonce);\n  address_pool.push(nonce_address);\n\n  // ---------- input: publicKey (buf)\n\n  publicKey = _any_to_Uint8Array(address_pool, publicKey, \"publicKey\");\n  var publicKey_address,\n    publicKey_length = libsodium._crypto_box_publickeybytes() | 0;\n  if (publicKey.length !== publicKey_length) {\n    _free_and_throw_type_error(address_pool, \"invalid publicKey length\");\n  }\n  publicKey_address = _to_allocated_buf_address(publicKey);\n  address_pool.push(publicKey_address);\n\n  // ---------- input: privateKey (buf)\n\n  privateKey = _any_to_Uint8Array(address_pool, privateKey, \"privateKey\");\n  var privateKey_address,\n    privateKey_length = libsodium._crypto_box_secretkeybytes() | 0;\n  if (privateKey.length !== privateKey_length) {\n    _free_and_throw_type_error(address_pool, \"invalid privateKey length\");\n  }\n  privateKey_address = _to_allocated_buf_address(privateKey);\n  address_pool.push(privateKey_address);\n\n  // ---------- output plaintext (buf)\n\n  var plaintext_length = (ciphertext_length - libsodium._crypto_box_macbytes()) | 0,\n    plaintext = new AllocatedBuf(plaintext_length),\n    plaintext_address = plaintext.address;\n\n  address_pool.push(plaintext_address);\n\n  if (\n    (libsodium._crypto_box_open_easy(\n      plaintext_address,\n      ciphertext_address,\n      ciphertext_length,\n      0,\n      nonce_address,\n      publicKey_address,\n      privateKey_address,\n    ) |\n      0) ===\n    0\n  ) {\n    var ret = _format_output(plaintext, outputFormat);\n    _free_all(address_pool);\n    return ret;\n  }\n  _free_and_throw_error(address_pool, \"incorrect key pair for the given ciphertext\");\n};\n\nexport const crypto_secretbox_easy = <T extends FormatReturnNames = \"uint8array\">(\n  message: Uint8Array,\n  nonce: Uint8Array,\n  key: Uint8Array,\n  outputFormat: T = \"uint8array\" as T,\n) => {\n  const address_pool = new AddressPool();\n\n  _check_output_format(outputFormat);\n  // ---------- input: message (unsized_buf)\n\n  message = _any_to_Uint8Array(address_pool, message, \"message\");\n  var message_address = _to_allocated_buf_address(message),\n    message_length = message.length;\n  address_pool.push(message_address);\n\n  // ---------- input: nonce (buf)\n\n  nonce = _any_to_Uint8Array(address_pool, nonce, \"nonce\");\n  var nonce_address,\n    nonce_length = libsodium._crypto_secretbox_noncebytes() | 0;\n  if (nonce.length !== nonce_length) {\n    _free_and_throw_type_error(address_pool, \"invalid nonce length\");\n  }\n  nonce_address = _to_allocated_buf_address(nonce);\n  address_pool.push(nonce_address);\n\n  // ---------- input: key (buf)\n\n  key = _any_to_Uint8Array(address_pool, key, \"key\");\n  var key_address,\n    key_length = libsodium._crypto_secretbox_keybytes() | 0;\n  if (key.length !== key_length) {\n    _free_and_throw_type_error(address_pool, \"invalid key length\");\n  }\n  key_address = _to_allocated_buf_address(key);\n  address_pool.push(key_address);\n\n  // ---------- output cipher (buf)\n\n  var cipher_length = (message_length + libsodium._crypto_secretbox_macbytes()) | 0,\n    cipher = new AllocatedBuf(cipher_length),\n    cipher_address = cipher.address;\n\n  address_pool.push(cipher_address);\n\n  if (\n    (libsodium._crypto_secretbox_easy(cipher_address, message_address, message_length, 0, nonce_address, key_address) |\n      0) ===\n    0\n  ) {\n    var ret = _format_output(cipher, outputFormat);\n    _free_all(address_pool);\n    return ret;\n  }\n  _free_and_throw_error(address_pool, \"invalid usage\");\n};\n\nexport const crypto_secretbox_open_easy = <T extends FormatReturnNames = \"uint8array\">(\n  ciphertext: Uint8Array,\n  nonce: Uint8Array,\n  key: Uint8Array,\n  outputFormat: T = \"uint8array\" as T,\n) => {\n  const address_pool = new AddressPool();\n\n  _check_output_format(outputFormat);\n  // ---------- input: ciphertext (minsized_buf)\n\n  ciphertext = _any_to_Uint8Array(address_pool, ciphertext, \"ciphertext\");\n  var ciphertext_address,\n    ciphertext_min_length = libsodium._crypto_secretbox_macbytes(),\n    ciphertext_length = ciphertext.length;\n  if (ciphertext_length < ciphertext_min_length) {\n    _free_and_throw_type_error(address_pool, \"ciphertext is too short\");\n  }\n  ciphertext_address = _to_allocated_buf_address(ciphertext);\n  address_pool.push(ciphertext_address);\n\n  // ---------- input: nonce (buf)\n\n  nonce = _any_to_Uint8Array(address_pool, nonce, \"nonce\");\n  var nonce_address,\n    nonce_length = libsodium._crypto_secretbox_noncebytes() | 0;\n  if (nonce.length !== nonce_length) {\n    _free_and_throw_type_error(address_pool, \"invalid nonce length\");\n  }\n  nonce_address = _to_allocated_buf_address(nonce);\n  address_pool.push(nonce_address);\n\n  // ---------- input: key (buf)\n\n  key = _any_to_Uint8Array(address_pool, key, \"key\");\n  var key_address,\n    key_length = libsodium._crypto_secretbox_keybytes() | 0;\n  if (key.length !== key_length) {\n    _free_and_throw_type_error(address_pool, \"invalid key length\");\n  }\n  key_address = _to_allocated_buf_address(key);\n  address_pool.push(key_address);\n\n  // ---------- output message (buf)\n\n  var message_length = (ciphertext_length - libsodium._crypto_secretbox_macbytes()) | 0,\n    message = new AllocatedBuf(message_length),\n    message_address = message.address;\n\n  address_pool.push(message_address);\n\n  if (\n    (libsodium._crypto_secretbox_open_easy(\n      message_address,\n      ciphertext_address,\n      ciphertext_length,\n      0,\n      nonce_address,\n      key_address,\n    ) |\n      0) ===\n    0\n  ) {\n    var ret = _format_output(message, outputFormat);\n    _free_all(address_pool);\n    return ret;\n  }\n  _free_and_throw_error(address_pool, \"wrong secret key for the given ciphertext\");\n};\n\nexport const crypto_sign = <T extends FormatReturnNames = \"uint8array\">(\n  message: Uint8Array,\n  privateKey: Uint8Array,\n  outputFormat: T = \"uint8array\" as T,\n) => {\n  const address_pool = new AddressPool();\n\n  _check_output_format(outputFormat);\n  // ---------- input: message (unsized_buf)\n\n  message = _any_to_Uint8Array(address_pool, message, \"message\");\n  var message_address = _to_allocated_buf_address(message),\n    message_length = message.length;\n  address_pool.push(message_address);\n\n  // ---------- input: privateKey (buf)\n\n  privateKey = _any_to_Uint8Array(address_pool, privateKey, \"privateKey\");\n  var privateKey_address,\n    privateKey_length = libsodium._crypto_sign_secretkeybytes() | 0;\n  if (privateKey.length !== privateKey_length) {\n    _free_and_throw_type_error(address_pool, \"invalid privateKey length\");\n  }\n  privateKey_address = _to_allocated_buf_address(privateKey);\n  address_pool.push(privateKey_address);\n\n  // ---------- output signature (buf)\n\n  var signature_length = (message.length + libsodium._crypto_sign_bytes()) | 0,\n    signature = new AllocatedBuf(signature_length),\n    signature_address = signature.address;\n\n  address_pool.push(signature_address);\n\n  if (\n    (libsodium._crypto_sign(signature_address, null, message_address, message_length, 0, privateKey_address) | 0) ===\n    0\n  ) {\n    var ret = _format_output(signature, outputFormat);\n    _free_all(address_pool);\n    return ret;\n  }\n  _free_and_throw_error(address_pool, \"invalid usage\");\n};\n\nexport const crypto_sign_detached = <T extends FormatReturnNames = \"uint8array\">(\n  message: Uint8Array,\n  privateKey: Uint8Array,\n  outputFormat: T = \"uint8array\" as T,\n) => {\n  const address_pool = new AddressPool();\n\n  _check_output_format(outputFormat);\n  // ---------- input: message (unsized_buf)\n\n  message = _any_to_Uint8Array(address_pool, message, \"message\");\n  var message_address = _to_allocated_buf_address(message),\n    message_length = message.length;\n  address_pool.push(message_address);\n\n  // ---------- input: privateKey (buf)\n\n  privateKey = _any_to_Uint8Array(address_pool, privateKey, \"privateKey\");\n  var privateKey_address,\n    privateKey_length = libsodium._crypto_sign_secretkeybytes() | 0;\n  if (privateKey.length !== privateKey_length) {\n    _free_and_throw_type_error(address_pool, \"invalid privateKey length\");\n  }\n  privateKey_address = _to_allocated_buf_address(privateKey);\n  address_pool.push(privateKey_address);\n\n  // ---------- output signature (buf)\n\n  var signature_length = libsodium._crypto_sign_bytes() | 0,\n    signature = new AllocatedBuf(signature_length),\n    signature_address = signature.address;\n\n  address_pool.push(signature_address);\n\n  if (\n    (libsodium._crypto_sign_detached(signature_address, null, message_address, message_length, 0, privateKey_address) |\n      0) ===\n    0\n  ) {\n    var ret = _format_output(signature, outputFormat);\n    _free_all(address_pool);\n    return ret;\n  }\n  _free_and_throw_error(address_pool, \"invalid usage\");\n};\n\nexport const crypto_sign_ed25519_pk_to_curve25519 = <T extends FormatReturnNames = \"uint8array\">(\n  edPk: Uint8Array,\n  outputFormat: T = \"uint8array\" as T,\n) => {\n  const address_pool = new AddressPool();\n\n  _check_output_format(outputFormat);\n  // ---------- input: edPk (buf)\n\n  edPk = _any_to_Uint8Array(address_pool, edPk, \"edPk\");\n  var edPk_address,\n    edPk_length = libsodium._crypto_sign_publickeybytes() | 0;\n  if (edPk.length !== edPk_length) {\n    _free_and_throw_type_error(address_pool, \"invalid edPk length\");\n  }\n  edPk_address = _to_allocated_buf_address(edPk);\n  address_pool.push(edPk_address);\n\n  // ---------- output cPk (buf)\n\n  var cPk_length = libsodium._crypto_scalarmult_scalarbytes() | 0,\n    cPk = new AllocatedBuf(cPk_length),\n    cPk_address = cPk.address;\n\n  address_pool.push(cPk_address);\n\n  if ((libsodium._crypto_sign_ed25519_pk_to_curve25519(cPk_address, edPk_address) | 0) === 0) {\n    var ret = _format_output(cPk, outputFormat);\n    _free_all(address_pool);\n    return ret;\n  }\n  _free_and_throw_error(address_pool, \"invalid key\");\n};\n\nexport const crypto_sign_ed25519_sk_to_curve25519 = <T extends FormatReturnNames = \"uint8array\">(\n  edSk: Uint8Array,\n  outputFormat: T = \"uint8array\" as T,\n) => {\n  const address_pool = new AddressPool();\n\n  _check_output_format(outputFormat);\n  // ---------- input: edSk (buf)\n\n  edSk = _any_to_Uint8Array(address_pool, edSk, \"edSk\");\n  var edSk_address,\n    edSk_length = libsodium._crypto_sign_secretkeybytes() | 0;\n  if (edSk.length !== edSk_length) {\n    _free_and_throw_type_error(address_pool, \"invalid edSk length\");\n  }\n  edSk_address = _to_allocated_buf_address(edSk);\n  address_pool.push(edSk_address);\n\n  // ---------- output cSk (buf)\n\n  var cSk_length = libsodium._crypto_scalarmult_scalarbytes() | 0,\n    cSk = new AllocatedBuf(cSk_length),\n    cSk_address = cSk.address;\n\n  address_pool.push(cSk_address);\n\n  if ((libsodium._crypto_sign_ed25519_sk_to_curve25519(cSk_address, edSk_address) | 0) === 0) {\n    var ret = _format_output(cSk, outputFormat);\n    _free_all(address_pool);\n    return ret;\n  }\n  _free_and_throw_error(address_pool, \"invalid key\");\n};\n\nexport const crypto_sign_final_create = <T extends FormatReturnNames = \"uint8array\">(\n  state_address: number,\n  privateKey: Uint8Array,\n  outputFormat: T = \"uint8array\" as T,\n) => {\n  const address_pool = new AddressPool();\n\n  _check_output_format(outputFormat);\n  // ---------- input: state_address (sign_state_address)\n\n  _require_defined(address_pool, state_address, \"state_address\");\n\n  // ---------- input: privateKey (buf)\n\n  privateKey = _any_to_Uint8Array(address_pool, privateKey, \"privateKey\");\n  var privateKey_address,\n    privateKey_length = libsodium._crypto_sign_secretkeybytes() | 0;\n  if (privateKey.length !== privateKey_length) {\n    _free_and_throw_type_error(address_pool, \"invalid privateKey length\");\n  }\n  privateKey_address = _to_allocated_buf_address(privateKey);\n  address_pool.push(privateKey_address);\n\n  // ---------- output signature (buf)\n\n  var signature_length = libsodium._crypto_sign_bytes() | 0,\n    signature = new AllocatedBuf(signature_length),\n    signature_address = signature.address;\n\n  address_pool.push(signature_address);\n\n  if ((libsodium._crypto_sign_final_create(state_address, signature_address, null, privateKey_address) | 0) === 0) {\n    var ret = (libsodium._free(state_address), _format_output(signature, outputFormat));\n    _free_all(address_pool);\n    return ret;\n  }\n  _free_and_throw_error(address_pool, \"invalid usage\");\n};\n\nexport const crypto_sign_final_verify = <T extends FormatReturnNames = \"uint8array\">(\n  state_address: number,\n  signature: Uint8Array,\n  publicKey: Uint8Array,\n  outputFormat: T = \"uint8array\" as T,\n) => {\n  const address_pool = new AddressPool();\n\n  _check_output_format(outputFormat);\n  // ---------- input: state_address (sign_state_address)\n\n  _require_defined(address_pool, state_address, \"state_address\");\n\n  // ---------- input: signature (buf)\n\n  signature = _any_to_Uint8Array(address_pool, signature, \"signature\");\n  var signature_address,\n    signature_length = libsodium._crypto_sign_bytes() | 0;\n  if (signature.length !== signature_length) {\n    _free_and_throw_type_error(address_pool, \"invalid signature length\");\n  }\n  signature_address = _to_allocated_buf_address(signature);\n  address_pool.push(signature_address);\n\n  // ---------- input: publicKey (buf)\n\n  publicKey = _any_to_Uint8Array(address_pool, publicKey, \"publicKey\");\n  var publicKey_address,\n    publicKey_length = libsodium._crypto_sign_publickeybytes() | 0;\n  if (publicKey.length !== publicKey_length) {\n    _free_and_throw_type_error(address_pool, \"invalid publicKey length\");\n  }\n  publicKey_address = _to_allocated_buf_address(publicKey);\n  address_pool.push(publicKey_address);\n\n  var verificationResult = libsodium._crypto_sign_final_verify(state_address, signature_address, publicKey_address) | 0;\n  var ret = verificationResult === 0;\n  _free_all(address_pool);\n  return ret;\n};\n\nexport const crypto_sign_init = <T extends FormatReturnNames = \"uint8array\">(outputFormat: T = \"uint8array\" as T) => {\n  const address_pool = new AddressPool();\n\n  _check_output_format(outputFormat);\n  // ---------- output state (sign_state)\n\n  var state_address = new AllocatedBuf(208).address;\n\n  if ((libsodium._crypto_sign_init(state_address) | 0) === 0) {\n    var ret = state_address;\n    _free_all(address_pool);\n    return ret;\n  }\n  _free_and_throw_error(address_pool, \"internal error\");\n};\n\nexport const crypto_sign_keypair = <T extends FormatReturnNames = \"uint8array\">(\n  outputFormat: T = \"uint8array\" as T,\n) => {\n  const address_pool = new AddressPool();\n\n  _check_output_format(outputFormat);\n  // ---------- output publicKey (buf)\n\n  var publicKey_length = libsodium._crypto_sign_publickeybytes() | 0,\n    publicKey = new AllocatedBuf(publicKey_length),\n    publicKey_address = publicKey.address;\n\n  address_pool.push(publicKey_address);\n\n  // ---------- output privateKey (buf)\n\n  var privateKey_length = libsodium._crypto_sign_secretkeybytes() | 0,\n    privateKey = new AllocatedBuf(privateKey_length),\n    privateKey_address = privateKey.address;\n\n  address_pool.push(privateKey_address);\n\n  if ((libsodium._crypto_sign_keypair(publicKey_address, privateKey_address) | 0) === 0) {\n    var ret = {\n      publicKey: _format_output(publicKey, outputFormat),\n      privateKey: _format_output(privateKey, outputFormat),\n      keyType: \"ed25519\",\n    };\n    _free_all(address_pool);\n    return ret;\n  }\n  _free_and_throw_error(address_pool, \"internal error\");\n};\n\nexport const crypto_sign_open = <T extends FormatReturnNames = \"uint8array\">(\n  signedMessage: Uint8Array,\n  publicKey: Uint8Array,\n  outputFormat: T = \"uint8array\" as T,\n) => {\n  const address_pool = new AddressPool();\n\n  _check_output_format(outputFormat);\n  // ---------- input: signedMessage (minsized_buf)\n\n  signedMessage = _any_to_Uint8Array(address_pool, signedMessage, \"signedMessage\");\n  var signedMessage_address,\n    signedMessage_min_length = libsodium._crypto_sign_bytes(),\n    signedMessage_length = signedMessage.length;\n  if (signedMessage_length < signedMessage_min_length) {\n    _free_and_throw_type_error(address_pool, \"signedMessage is too short\");\n  }\n  signedMessage_address = _to_allocated_buf_address(signedMessage);\n  address_pool.push(signedMessage_address);\n\n  // ---------- input: publicKey (buf)\n\n  publicKey = _any_to_Uint8Array(address_pool, publicKey, \"publicKey\");\n  var publicKey_address,\n    publicKey_length = libsodium._crypto_sign_publickeybytes() | 0;\n  if (publicKey.length !== publicKey_length) {\n    _free_and_throw_type_error(address_pool, \"invalid publicKey length\");\n  }\n  publicKey_address = _to_allocated_buf_address(publicKey);\n  address_pool.push(publicKey_address);\n\n  // ---------- output message (buf)\n\n  var message_length = (signedMessage_length - libsodium._crypto_sign_bytes()) | 0,\n    message = new AllocatedBuf(message_length),\n    message_address = message.address;\n\n  address_pool.push(message_address);\n\n  if (\n    (libsodium._crypto_sign_open(\n      message_address,\n      null,\n      signedMessage_address,\n      signedMessage_length,\n      0,\n      publicKey_address,\n    ) |\n      0) ===\n    0\n  ) {\n    var ret = _format_output(message, outputFormat);\n    _free_all(address_pool);\n    return ret;\n  }\n  _free_and_throw_error(address_pool, \"incorrect signature for the given public key\");\n};\n\nexport const crypto_sign_seed_keypair = <T extends FormatReturnNames = \"uint8array\">(\n  seed: Uint8Array,\n  outputFormat: T = \"uint8array\" as T,\n) => {\n  const address_pool = new AddressPool();\n\n  _check_output_format(outputFormat);\n  // ---------- input: seed (buf)\n\n  seed = _any_to_Uint8Array(address_pool, seed, \"seed\");\n  var seed_address,\n    seed_length = libsodium._crypto_sign_seedbytes() | 0;\n  if (seed.length !== seed_length) {\n    _free_and_throw_type_error(address_pool, \"invalid seed length\");\n  }\n  seed_address = _to_allocated_buf_address(seed);\n  address_pool.push(seed_address);\n\n  // ---------- output publicKey (buf)\n\n  var publicKey_length = libsodium._crypto_sign_publickeybytes() | 0,\n    publicKey = new AllocatedBuf(publicKey_length),\n    publicKey_address = publicKey.address;\n\n  address_pool.push(publicKey_address);\n\n  // ---------- output privateKey (buf)\n\n  var privateKey_length = libsodium._crypto_sign_secretkeybytes() | 0,\n    privateKey = new AllocatedBuf(privateKey_length),\n    privateKey_address = privateKey.address;\n\n  address_pool.push(privateKey_address);\n\n  if ((libsodium._crypto_sign_seed_keypair(publicKey_address, privateKey_address, seed_address) | 0) === 0) {\n    var ret = {\n      publicKey: _format_output(publicKey, outputFormat),\n      privateKey: _format_output(privateKey, outputFormat),\n      keyType: \"ed25519\",\n    };\n    _free_all(address_pool);\n    return ret;\n  }\n  _free_and_throw_error(address_pool, \"invalid usage\");\n};\n\nexport const crypto_sign_update = <T extends FormatReturnNames = \"uint8array\">(\n  state_address: number,\n  message_chunk: Uint8Array,\n  outputFormat: T = \"uint8array\" as T,\n) => {\n  const address_pool = new AddressPool();\n\n  _check_output_format(outputFormat);\n  // ---------- input: state_address (sign_state_address)\n\n  _require_defined(address_pool, state_address, \"state_address\");\n\n  // ---------- input: message_chunk (unsized_buf)\n\n  message_chunk = _any_to_Uint8Array(address_pool, message_chunk, \"message_chunk\");\n  var message_chunk_address = _to_allocated_buf_address(message_chunk),\n    message_chunk_length = message_chunk.length;\n  address_pool.push(message_chunk_address);\n\n  if (!((libsodium._crypto_sign_update(state_address, message_chunk_address, message_chunk_length, 0) | 0) === 0)) {\n    _free_and_throw_error(address_pool, \"invalid usage\");\n  }\n  _free_all(address_pool);\n};\n\nexport const crypto_sign_verify_detached = (signature: Uint8Array, message: Uint8Array, publicKey: Uint8Array) => {\n  const address_pool = new AddressPool();\n\n  // ---------- input: signature (buf)\n\n  signature = _any_to_Uint8Array(address_pool, signature, \"signature\");\n  var signature_address,\n    signature_length = libsodium._crypto_sign_bytes() | 0;\n  if (signature.length !== signature_length) {\n    _free_and_throw_type_error(address_pool, \"invalid signature length\");\n  }\n  signature_address = _to_allocated_buf_address(signature);\n  address_pool.push(signature_address);\n\n  // ---------- input: message (unsized_buf)\n\n  message = _any_to_Uint8Array(address_pool, message, \"message\");\n  var message_address = _to_allocated_buf_address(message),\n    message_length = message.length;\n  address_pool.push(message_address);\n\n  // ---------- input: publicKey (buf)\n\n  publicKey = _any_to_Uint8Array(address_pool, publicKey, \"publicKey\");\n  var publicKey_address,\n    publicKey_length = libsodium._crypto_sign_publickeybytes() | 0;\n  if (publicKey.length !== publicKey_length) {\n    _free_and_throw_type_error(address_pool, \"invalid publicKey length\");\n  }\n  publicKey_address = _to_allocated_buf_address(publicKey);\n  address_pool.push(publicKey_address);\n\n  var verificationResult =\n    libsodium._crypto_sign_verify_detached(signature_address, message_address, message_length, 0, publicKey_address) |\n    0;\n  var ret = verificationResult === 0;\n  _free_all(address_pool);\n  return ret;\n};\n\nexport const randombytes_buf = <T extends FormatReturnNames = \"uint8array\">(\n  length: number,\n  outputFormat: T = \"uint8array\" as T,\n) => {\n  const address_pool = new AddressPool();\n\n  _check_output_format(outputFormat);\n  // ---------- input: length (uint)\n\n  _require_defined(address_pool, length, \"length\");\n\n  if (!(typeof length === \"number\" && (length | 0) === length) || length < 0) {\n    _free_and_throw_type_error(address_pool, \"length must be an unsigned integer\");\n  }\n\n  // ---------- output output (buf)\n\n  var output_length = length | 0,\n    output = new AllocatedBuf(output_length),\n    output_address = output.address;\n\n  address_pool.push(output_address);\n\n  libsodium._randombytes_buf(output_address, length);\n  var ret = _format_output(output, outputFormat);\n  _free_all(address_pool);\n  return ret;\n};\n\nexport const randombytes_buf_deterministic = <T extends FormatReturnNames = \"uint8array\">(\n  length: number,\n  seed: Uint8Array,\n  outputFormat: T = \"uint8array\" as T,\n) => {\n  const address_pool = new AddressPool();\n\n  _check_output_format(outputFormat);\n  // ---------- input: length (uint)\n\n  _require_defined(address_pool, length, \"length\");\n\n  if (!(typeof length === \"number\" && (length | 0) === length) || length < 0) {\n    _free_and_throw_type_error(address_pool, \"length must be an unsigned integer\");\n  }\n\n  // ---------- input: seed (buf)\n\n  seed = _any_to_Uint8Array(address_pool, seed, \"seed\");\n  var seed_address,\n    seed_length = libsodium._randombytes_seedbytes() | 0;\n  if (seed.length !== seed_length) {\n    _free_and_throw_type_error(address_pool, \"invalid seed length\");\n  }\n  seed_address = _to_allocated_buf_address(seed);\n  address_pool.push(seed_address);\n\n  // ---------- output output (buf)\n\n  var output_length = length | 0,\n    output = new AllocatedBuf(output_length),\n    output_address = output.address;\n\n  address_pool.push(output_address);\n\n  libsodium._randombytes_buf_deterministic(output_address, length, seed_address);\n  var ret = _format_output(output, outputFormat);\n  _free_all(address_pool);\n  return ret;\n};\n\nexport const randombytes_close = <T extends FormatReturnNames = \"uint8array\">(outputFormat: T = \"uint8array\" as T) => {\n  const address_pool = new AddressPool();\n\n  _check_output_format(outputFormat);\n  libsodium._randombytes_close();\n};\n\nexport const randombytes_random = <T extends FormatReturnNames = \"uint8array\">(outputFormat: T = \"uint8array\" as T) => {\n  const address_pool = new AddressPool();\n\n  _check_output_format(outputFormat);\n  var random_value = libsodium._randombytes_random() >>> 0;\n  var ret = random_value;\n  _free_all(address_pool);\n  return ret;\n};\n\nexport const randombytes_stir = <T extends FormatReturnNames = \"uint8array\">(outputFormat: T = \"uint8array\" as T) => {\n  const address_pool = new AddressPool();\n\n  _check_output_format(outputFormat);\n  libsodium._randombytes_stir();\n};\n\nexport const randombytes_uniform = <T extends FormatReturnNames = \"uint8array\">(\n  upper_bound: number,\n  outputFormat: T = \"uint8array\" as T,\n) => {\n  const address_pool = new AddressPool();\n\n  _check_output_format(outputFormat);\n  // ---------- input: upper_bound (uint)\n\n  _require_defined(address_pool, upper_bound, \"upper_bound\");\n\n  if (!(typeof upper_bound === \"number\" && (upper_bound | 0) === upper_bound) || upper_bound < 0) {\n    _free_and_throw_type_error(address_pool, \"upper_bound must be an unsigned integer\");\n  }\n\n  var random_value = libsodium._randombytes_uniform(upper_bound) >>> 0;\n  var ret = random_value;\n  _free_all(address_pool);\n  return ret;\n};\n\nexport const sodium_version_string = () => {\n  const address_pool = new AddressPool();\n\n  var version = libsodium._sodium_version_string();\n  var ret = libsodium.UTF8ToString(version);\n  _free_all(address_pool);\n  return ret;\n};\n"],"names":["$cc85b87efeeb9079ba1ecaaf86b2e3db$export$9099ad97b570f7c","Module","readyPromiseResolve","readyPromiseReject","Promise","resolve","reject","wasmMemory","err","console","warn","bind","WebAssembly","abort","ABORT","buffer","HEAP8","HEAPU8","HEAP16","HEAP32","HEAPF32","HEAPF64","UTF8Decoder","TextDecoder","undefined","UTF8ToString","ptr","maxBytesToRead","heap","idx","endIdx","endPtr","subarray","decode","str","u0","u1","u2","String","fromCharCode","ch","UTF8ArrayToString","updateGlobalBufferAndViews","buf","Int8Array","Int16Array","Int32Array","Uint8Array","Uint16Array","Uint32Array","Float32Array","Float64Array","wasmTable","__ATPRERUN__","__ATINIT__","__ATPOSTRUN__","tempDouble","tempI64","runDependencies","runDependencyWatcher","dependenciesFulfilled","what","e","RuntimeError","ASM_CONSTS","35180","getRandomValue","35216","crypto","getRandomValues","callRuntimeCallbacks","callbacks","length","callback","shift","func","arg","get","readAsmConstArgsArray","emscripten_realloc_buffer","size","grow","byteLength","calledRun","asmLibraryArg","b","condition","filename","line","c","a","code","sigPtr","argbuf","args","double","push","readAsmConstArgs","apply","d","dest","src","num","copyWithin","f","requestedSize","x","multiple","oldSize","maxHeapSize","cutDown","overGrownHeapSize","Math","min","max","info","receiveInstance","instance","exports","cb","unshift","id","clearInterval","removeRunDependency","instantiateStreaming","fetch","credentials","e1","createWasm","arguments","run","doRun","postRun","preRun","setTimeout","value","type","noSafe","charAt","abs","floor","ceil","runCaller","pop","ready","libsodium","_installRes","install","options","_install","async","instantiateWasm","_sodium_init","Error","message","nonce","randombytes_buf","CONSTANTS","crypto_secretbox_NONCEBYTES","key","crypto_secretbox_KEYBYTES","encrypted","crypto_secretbox_easy","b1","b2","TypeError","i","j","memcmp","crypto_secretbox_open_easy","log","dec","TextEncoder","from_string","encode","enc","fatal","to_string","from_hex","input","address_pool","AddressPool","inputU8","_any_to_Uint8Array","result","AllocatedBuf","input_address","_to_allocated_buf_address","hex_end_p","_malloc","address","_sodium_hex2bin","_free_and_throw_error","getValue","result_str","to_Uint8Array","_free_all","to_hex","base64_variants1","check_base64_variant","variant","base64_variants","URLSAFE_NO_PADDING","ORIGINAL","ORIGINAL_NO_PADDING","URLSAFE","from_base64","result_bin_len_p","b64_end_p","_sodium_base642bin","result_bin","to_base64","nibbles","remainder","b64_len","_sodium_bin2base64","result_b64","output_formats","Object","freeze","_format_output","output","optionalOutputFormat","selectedOutputFormat","_is_output_format","format","includes","_check_output_format","[object Object]","this","set","Array","add","bytes","length1","addresses","_free","_free_and_throw_type_error","_require_defined","varValue","varName","_cacheDefineConstantsProp","defineProperty","writable","configurable","enumerable","constantsValue","_sodium_library_version_major","_sodium_library_version_minor","_sodium_version_string","_crypto_box_macbytes","_crypto_box_noncebytes","_crypto_box_publickeybytes","_crypto_box_secretkeybytes","_crypto_scalarmult_scalarbytes","_crypto_secretbox_keybytes","_crypto_secretbox_macbytes","_crypto_secretbox_noncebytes","_crypto_sign_bytes","_crypto_sign_messagebytes_max","_crypto_sign_publickeybytes","_crypto_sign_secretkeybytes","_crypto_sign_seedbytes","crypto_box_easy","publicKey","privateKey","outputFormat","message_address","message_length","nonce_address","nonce_length","publicKey_address","publicKey_length","privateKey_address","privateKey_length","ciphertext_length","ciphertext","ciphertext_address","_crypto_box_easy","ret","crypto_box_open_easy","ciphertext_min_length","plaintext_length","plaintext","plaintext_address","_crypto_box_open_easy","key_address","key_length","cipher_length","cipher","cipher_address","_crypto_secretbox_easy","_crypto_secretbox_open_easy","crypto_sign","signature_length","signature","signature_address","_crypto_sign","crypto_sign_detached","_crypto_sign_detached","crypto_sign_ed25519_pk_to_curve25519","edPk","edPk_address","edPk_length","cPk_length","cPk","cPk_address","_crypto_sign_ed25519_pk_to_curve25519","crypto_sign_ed25519_sk_to_curve25519","edSk","edSk_address","edSk_length","cSk_length","cSk","cSk_address","_crypto_sign_ed25519_sk_to_curve25519","crypto_sign_final_create","state_address","_crypto_sign_final_create","crypto_sign_final_verify","_crypto_sign_final_verify","crypto_sign_init","_crypto_sign_init","crypto_sign_keypair","_crypto_sign_keypair","keyType","crypto_sign_open","signedMessage","signedMessage_address","signedMessage_min_length","signedMessage_length","_crypto_sign_open","crypto_sign_seed_keypair","seed","seed_address","seed_length","_crypto_sign_seed_keypair","crypto_sign_update","message_chunk","message_chunk_address","message_chunk_length","_crypto_sign_update","crypto_sign_verify_detached","_crypto_sign_verify_detached","output_address","_randombytes_buf","randombytes_buf_deterministic","_randombytes_seedbytes","_randombytes_buf_deterministic","randombytes_close","_randombytes_close","randombytes_random","_randombytes_random","randombytes_stir","_randombytes_stir","randombytes_uniform","upper_bound","_randombytes_uniform","sodium_version_string","version"],"version":3,"file":"index.js.map"}